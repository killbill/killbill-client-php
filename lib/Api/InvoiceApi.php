<?php
/**
 * InvoiceApi
 * PHP version 5
 *
 * @category Class
 * @package  Killbill\Client\Swagger
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Kill Bill
 *
 * Kill Bill is an open-source billing and payments platform
 *
 * OpenAPI spec version: 0.20.11
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.12
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Killbill\Client\Swagger\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Psr7\Response;
use GuzzleHttp\RequestOptions;
use Killbill\Client\Swagger\ApiException;
use Killbill\Client\Swagger\Configuration;
use Killbill\Client\Swagger\HeaderSelector;
use Killbill\Client\Swagger\ObjectSerializer;

/**
 * InvoiceApi Class Doc Comment
 *
 * @category Class
 * @package  Killbill\Client\Swagger
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class InvoiceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation adjustInvoiceItem
     *
     * Adjust an invoice item
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $invoiceId invoiceId (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     * @param \DateTime|null $requestedDate requestedDate (optional)
     * @param string[]|null $pluginProperty pluginProperty (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Invoice
     */
    public function adjustInvoiceItem($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null, $requestedDate = null, $pluginProperty = null)
    {
        list($response) = $this->adjustInvoiceItemWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment, $requestedDate, $pluginProperty);
        return $response;
    }

    /**
     * Operation adjustInvoiceItemWithHttpInfo
     *
     * Adjust an invoice item
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $requestedDate (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function adjustInvoiceItemWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null, $requestedDate = null, $pluginProperty = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->adjustInvoiceItemRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment, $requestedDate, $pluginProperty);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adjustInvoiceItemAsync
     *
     * Adjust an invoice item
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $requestedDate (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adjustInvoiceItemAsync($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null, $requestedDate = null, $pluginProperty = null)
    {
        return $this->adjustInvoiceItemAsyncWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment, $requestedDate, $pluginProperty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adjustInvoiceItemAsyncWithHttpInfo
     *
     * Adjust an invoice item
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $requestedDate (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adjustInvoiceItemAsyncWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null, $requestedDate = null, $pluginProperty = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->adjustInvoiceItemRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment, $requestedDate, $pluginProperty);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adjustInvoiceItem'
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $requestedDate (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function adjustInvoiceItemRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null, $requestedDate = null, $pluginProperty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling adjustInvoiceItem'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling adjustInvoiceItem'
            );
        }
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling adjustInvoiceItem'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($requestedDate !== null) {
            $queryParams['requestedDate'] = ObjectSerializer::toQueryValue($requestedDate);
        }
        // query params
        if (is_array($pluginProperty)) {
            $pluginProperty = ObjectSerializer::serializeCollection($pluginProperty, /*'multi'*/'csv', true);
        }
        if ($pluginProperty !== null) {
            $queryParams['pluginProperty'] = ObjectSerializer::toQueryValue($pluginProperty);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation commitInvoice
     *
     * Perform the invoice status transition from DRAFT to COMMITTED
     *
     * @param string $invoiceId invoiceId (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function commitInvoice($invoiceId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $this->commitInvoiceWithHttpInfo($invoiceId, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);
    }

    /**
     * Operation commitInvoiceWithHttpInfo
     *
     * Perform the invoice status transition from DRAFT to COMMITTED
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function commitInvoiceWithHttpInfo($invoiceId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->commitInvoiceRequest($invoiceId, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation commitInvoiceAsync
     *
     * Perform the invoice status transition from DRAFT to COMMITTED
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function commitInvoiceAsync($invoiceId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->commitInvoiceAsyncWithHttpInfo($invoiceId, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation commitInvoiceAsyncWithHttpInfo
     *
     * Perform the invoice status transition from DRAFT to COMMITTED
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function commitInvoiceAsyncWithHttpInfo($invoiceId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->commitInvoiceRequest($invoiceId, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'commitInvoice'
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function commitInvoiceRequest($invoiceId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling commitInvoice'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling commitInvoice'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}/commitInvoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createExternalCharges
     *
     * Create external charge(s)
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $accountId accountId (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     * @param \DateTime|null $requestedDate requestedDate (optional)
     * @param bool|null $autoCommit autoCommit (optional)
     * @param string[]|null $pluginProperty pluginProperty (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\InvoiceItem[]
     */
    public function createExternalCharges($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $requestedDate = null, $autoCommit = null, $pluginProperty = null)
    {
        list($response) = $this->createExternalChargesWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $requestedDate, $autoCommit, $pluginProperty);
        return $response;
    }

    /**
     * Operation createExternalChargesWithHttpInfo
     *
     * Create external charge(s)
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $requestedDate (optional)
     * @param bool $autoCommit (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\InvoiceItem[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createExternalChargesWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $requestedDate = null, $autoCommit = null, $pluginProperty = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\InvoiceItem[]';
        $request = $this->createExternalChargesRequest($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $requestedDate, $autoCommit, $pluginProperty);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\InvoiceItem[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createExternalChargesAsync
     *
     * Create external charge(s)
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $requestedDate (optional)
     * @param bool $autoCommit (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExternalChargesAsync($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $requestedDate = null, $autoCommit = null, $pluginProperty = null)
    {
        return $this->createExternalChargesAsyncWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $requestedDate, $autoCommit, $pluginProperty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createExternalChargesAsyncWithHttpInfo
     *
     * Create external charge(s)
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $requestedDate (optional)
     * @param bool $autoCommit (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExternalChargesAsyncWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $requestedDate = null, $autoCommit = null, $pluginProperty = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\InvoiceItem[]';
        $request = $this->createExternalChargesRequest($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $requestedDate, $autoCommit, $pluginProperty);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createExternalCharges'
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $requestedDate (optional)
     * @param bool $autoCommit (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createExternalChargesRequest($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $requestedDate = null, $autoCommit = null, $pluginProperty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createExternalCharges'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling createExternalCharges'
            );
        }
        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling createExternalCharges'
            );
        }

        $resourcePath = '/1.0/kb/invoices/charges/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($requestedDate !== null) {
            $queryParams['requestedDate'] = ObjectSerializer::toQueryValue($requestedDate);
        }
        // query params
        if ($autoCommit !== null) {
            $queryParams['autoCommit'] = ObjectSerializer::toQueryValue($autoCommit);
        }
        // query params
        if (is_array($pluginProperty)) {
            $pluginProperty = ObjectSerializer::serializeCollection($pluginProperty, /*'multi'*/'csv', true);
        }
        if ($pluginProperty !== null) {
            $queryParams['pluginProperty'] = ObjectSerializer::toQueryValue($pluginProperty);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($accountId !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($accountId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFutureInvoice
     *
     * Trigger an invoice generation
     *
     * @param string $accountId accountId (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param \DateTime|null $targetDate targetDate (optional)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Invoice
     */
    public function createFutureInvoice($accountId, $xKillbillCreatedBy, $targetDate = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        list($response) = $this->createFutureInvoiceWithHttpInfo($accountId, $xKillbillCreatedBy, $targetDate, $xKillbillReason, $xKillbillComment);
        return $response;
    }

    /**
     * Operation createFutureInvoiceWithHttpInfo
     *
     * Trigger an invoice generation
     *
     * @param string $accountId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param \DateTime $targetDate (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFutureInvoiceWithHttpInfo($accountId, $xKillbillCreatedBy, $targetDate = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->createFutureInvoiceRequest($accountId, $xKillbillCreatedBy, $targetDate, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createFutureInvoiceAsync
     *
     * Trigger an invoice generation
     *
     * @param string $accountId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param \DateTime $targetDate (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFutureInvoiceAsync($accountId, $xKillbillCreatedBy, $targetDate = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->createFutureInvoiceAsyncWithHttpInfo($accountId, $xKillbillCreatedBy, $targetDate, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFutureInvoiceAsyncWithHttpInfo
     *
     * Trigger an invoice generation
     *
     * @param string $accountId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param \DateTime $targetDate (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFutureInvoiceAsyncWithHttpInfo($accountId, $xKillbillCreatedBy, $targetDate = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->createFutureInvoiceRequest($accountId, $xKillbillCreatedBy, $targetDate, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFutureInvoice'
     *
     * @param string $accountId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param \DateTime $targetDate (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createFutureInvoiceRequest($accountId, $xKillbillCreatedBy, $targetDate = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling createFutureInvoice'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling createFutureInvoice'
            );
        }

        $resourcePath = '/1.0/kb/invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accountId !== null) {
            $queryParams['accountId'] = ObjectSerializer::toQueryValue($accountId);
        }
        // query params
        if ($targetDate !== null) {
            $queryParams['targetDate'] = ObjectSerializer::toQueryValue($targetDate);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInstantPayment
     *
     * Trigger a payment for invoice
     *
     * @param \Killbill\Client\Swagger\Model\InvoicePayment $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $invoiceId invoiceId (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     * @param bool|null $externalPayment externalPayment (optional)
     * @param string[]|null $pluginProperty pluginProperty (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\InvoicePayment
     */
    public function createInstantPayment($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null, $externalPayment = null, $pluginProperty = null)
    {
        list($response) = $this->createInstantPaymentWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment, $externalPayment, $pluginProperty);
        return $response;
    }

    /**
     * Operation createInstantPaymentWithHttpInfo
     *
     * Trigger a payment for invoice
     *
     * @param \Killbill\Client\Swagger\Model\InvoicePayment $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $externalPayment (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\InvoicePayment, HTTP status code, HTTP response headers (array of strings)
     */
    public function createInstantPaymentWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null, $externalPayment = null, $pluginProperty = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\InvoicePayment';
        $request = $this->createInstantPaymentRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment, $externalPayment, $pluginProperty);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\InvoicePayment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createInstantPaymentAsync
     *
     * Trigger a payment for invoice
     *
     * @param \Killbill\Client\Swagger\Model\InvoicePayment $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $externalPayment (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInstantPaymentAsync($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null, $externalPayment = null, $pluginProperty = null)
    {
        return $this->createInstantPaymentAsyncWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment, $externalPayment, $pluginProperty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInstantPaymentAsyncWithHttpInfo
     *
     * Trigger a payment for invoice
     *
     * @param \Killbill\Client\Swagger\Model\InvoicePayment $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $externalPayment (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInstantPaymentAsyncWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null, $externalPayment = null, $pluginProperty = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\InvoicePayment';
        $request = $this->createInstantPaymentRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment, $externalPayment, $pluginProperty);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInstantPayment'
     *
     * @param \Killbill\Client\Swagger\Model\InvoicePayment $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $externalPayment (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createInstantPaymentRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null, $externalPayment = null, $pluginProperty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createInstantPayment'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling createInstantPayment'
            );
        }
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling createInstantPayment'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}/payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($externalPayment !== null) {
            $queryParams['externalPayment'] = ObjectSerializer::toQueryValue($externalPayment);
        }
        // query params
        if (is_array($pluginProperty)) {
            $pluginProperty = ObjectSerializer::serializeCollection($pluginProperty, /*'multi'*/'csv', true);
        }
        if ($pluginProperty !== null) {
            $queryParams['pluginProperty'] = ObjectSerializer::toQueryValue($pluginProperty);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInvoiceCustomFields
     *
     * Add custom fields to invoice
     *
     * @param \Killbill\Client\Swagger\Model\CustomField[] $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $invoiceId invoiceId (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\CustomField[]
     */
    public function createInvoiceCustomFields($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        list($response) = $this->createInvoiceCustomFieldsWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment);
        return $response;
    }

    /**
     * Operation createInvoiceCustomFieldsWithHttpInfo
     *
     * Add custom fields to invoice
     *
     * @param \Killbill\Client\Swagger\Model\CustomField[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\CustomField[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createInvoiceCustomFieldsWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\CustomField[]';
        $request = $this->createInvoiceCustomFieldsRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\CustomField[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createInvoiceCustomFieldsAsync
     *
     * Add custom fields to invoice
     *
     * @param \Killbill\Client\Swagger\Model\CustomField[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceCustomFieldsAsync($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->createInvoiceCustomFieldsAsyncWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInvoiceCustomFieldsAsyncWithHttpInfo
     *
     * Add custom fields to invoice
     *
     * @param \Killbill\Client\Swagger\Model\CustomField[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceCustomFieldsAsyncWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\CustomField[]';
        $request = $this->createInvoiceCustomFieldsRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInvoiceCustomFields'
     *
     * @param \Killbill\Client\Swagger\Model\CustomField[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createInvoiceCustomFieldsRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createInvoiceCustomFields'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling createInvoiceCustomFields'
            );
        }
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling createInvoiceCustomFields'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}/customFields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInvoiceTags
     *
     * Add tags to invoice
     *
     * @param string[] $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $invoiceId invoiceId (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Tag[]
     */
    public function createInvoiceTags($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        list($response) = $this->createInvoiceTagsWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment);
        return $response;
    }

    /**
     * Operation createInvoiceTagsWithHttpInfo
     *
     * Add tags to invoice
     *
     * @param string[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Tag[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createInvoiceTagsWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Tag[]';
        $request = $this->createInvoiceTagsRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Tag[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createInvoiceTagsAsync
     *
     * Add tags to invoice
     *
     * @param string[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceTagsAsync($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->createInvoiceTagsAsyncWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInvoiceTagsAsyncWithHttpInfo
     *
     * Add tags to invoice
     *
     * @param string[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceTagsAsyncWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Tag[]';
        $request = $this->createInvoiceTagsRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInvoiceTags'
     *
     * @param string[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createInvoiceTagsRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createInvoiceTags'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling createInvoiceTags'
            );
        }
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling createInvoiceTags'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMigrationInvoice
     *
     * Create a migration invoice
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $accountId accountId (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     * @param \DateTime|null $targetDate targetDate (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Invoice
     */
    public function createMigrationInvoice($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $targetDate = null)
    {
        list($response) = $this->createMigrationInvoiceWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $targetDate);
        return $response;
    }

    /**
     * Operation createMigrationInvoiceWithHttpInfo
     *
     * Create a migration invoice
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $targetDate (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function createMigrationInvoiceWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $targetDate = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->createMigrationInvoiceRequest($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $targetDate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createMigrationInvoiceAsync
     *
     * Create a migration invoice
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $targetDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMigrationInvoiceAsync($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $targetDate = null)
    {
        return $this->createMigrationInvoiceAsyncWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $targetDate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMigrationInvoiceAsyncWithHttpInfo
     *
     * Create a migration invoice
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $targetDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMigrationInvoiceAsyncWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $targetDate = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->createMigrationInvoiceRequest($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $targetDate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMigrationInvoice'
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $targetDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createMigrationInvoiceRequest($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $targetDate = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createMigrationInvoice'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling createMigrationInvoice'
            );
        }
        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling createMigrationInvoice'
            );
        }

        $resourcePath = '/1.0/kb/invoices/migration/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($targetDate !== null) {
            $queryParams['targetDate'] = ObjectSerializer::toQueryValue($targetDate);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($accountId !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($accountId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTaxItems
     *
     * Create tax items
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $accountId accountId (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     * @param bool|null $autoCommit autoCommit (optional)
     * @param \DateTime|null $requestedDate requestedDate (optional)
     * @param string[]|null $pluginProperty pluginProperty (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\InvoiceItem[]
     */
    public function createTaxItems($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $autoCommit = null, $requestedDate = null, $pluginProperty = null)
    {
        list($response) = $this->createTaxItemsWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $autoCommit, $requestedDate, $pluginProperty);
        return $response;
    }

    /**
     * Operation createTaxItemsWithHttpInfo
     *
     * Create tax items
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $autoCommit (optional)
     * @param \DateTime $requestedDate (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\InvoiceItem[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createTaxItemsWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $autoCommit = null, $requestedDate = null, $pluginProperty = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\InvoiceItem[]';
        $request = $this->createTaxItemsRequest($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $autoCommit, $requestedDate, $pluginProperty);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\InvoiceItem[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTaxItemsAsync
     *
     * Create tax items
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $autoCommit (optional)
     * @param \DateTime $requestedDate (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaxItemsAsync($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $autoCommit = null, $requestedDate = null, $pluginProperty = null)
    {
        return $this->createTaxItemsAsyncWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $autoCommit, $requestedDate, $pluginProperty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTaxItemsAsyncWithHttpInfo
     *
     * Create tax items
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $autoCommit (optional)
     * @param \DateTime $requestedDate (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaxItemsAsyncWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $autoCommit = null, $requestedDate = null, $pluginProperty = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\InvoiceItem[]';
        $request = $this->createTaxItemsRequest($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $autoCommit, $requestedDate, $pluginProperty);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTaxItems'
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceItem[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $autoCommit (optional)
     * @param \DateTime $requestedDate (optional)
     * @param string[] $pluginProperty (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createTaxItemsRequest($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $autoCommit = null, $requestedDate = null, $pluginProperty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createTaxItems'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling createTaxItems'
            );
        }
        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling createTaxItems'
            );
        }

        $resourcePath = '/1.0/kb/invoices/taxes/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($autoCommit !== null) {
            $queryParams['autoCommit'] = ObjectSerializer::toQueryValue($autoCommit);
        }
        // query params
        if ($requestedDate !== null) {
            $queryParams['requestedDate'] = ObjectSerializer::toQueryValue($requestedDate);
        }
        // query params
        if (is_array($pluginProperty)) {
            $pluginProperty = ObjectSerializer::serializeCollection($pluginProperty, /*'multi'*/'csv', true);
        }
        if ($pluginProperty !== null) {
            $queryParams['pluginProperty'] = ObjectSerializer::toQueryValue($pluginProperty);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($accountId !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($accountId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCBA
     *
     * Delete a CBA item
     *
     * @param string $invoiceId invoiceId (required)
     * @param string $invoiceItemId invoiceItemId (required)
     * @param string $accountId accountId (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCBA($invoiceId, $invoiceItemId, $accountId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $this->deleteCBAWithHttpInfo($invoiceId, $invoiceItemId, $accountId, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);
    }

    /**
     * Operation deleteCBAWithHttpInfo
     *
     * Delete a CBA item
     *
     * @param string $invoiceId (required)
     * @param string $invoiceItemId (required)
     * @param string $accountId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCBAWithHttpInfo($invoiceId, $invoiceItemId, $accountId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deleteCBARequest($invoiceId, $invoiceItemId, $accountId, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCBAAsync
     *
     * Delete a CBA item
     *
     * @param string $invoiceId (required)
     * @param string $invoiceItemId (required)
     * @param string $accountId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCBAAsync($invoiceId, $invoiceItemId, $accountId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->deleteCBAAsyncWithHttpInfo($invoiceId, $invoiceItemId, $accountId, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCBAAsyncWithHttpInfo
     *
     * Delete a CBA item
     *
     * @param string $invoiceId (required)
     * @param string $invoiceItemId (required)
     * @param string $accountId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCBAAsyncWithHttpInfo($invoiceId, $invoiceItemId, $accountId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deleteCBARequest($invoiceId, $invoiceItemId, $accountId, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCBA'
     *
     * @param string $invoiceId (required)
     * @param string $invoiceItemId (required)
     * @param string $accountId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCBARequest($invoiceId, $invoiceItemId, $accountId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling deleteCBA'
            );
        }
        // verify the required parameter 'invoiceItemId' is set
        if ($invoiceItemId === null || (is_array($invoiceItemId) && count($invoiceItemId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceItemId when calling deleteCBA'
            );
        }
        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling deleteCBA'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling deleteCBA'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}/{invoiceItemId}/cba';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accountId !== null) {
            $queryParams['accountId'] = ObjectSerializer::toQueryValue($accountId);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }
        // path params
        if ($invoiceItemId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceItemId' . '}',
                ObjectSerializer::toPathValue($invoiceItemId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInvoiceCustomFields
     *
     * Remove custom fields from invoice
     *
     * @param string $invoiceId invoiceId (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string[]|null $customField customField (optional)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteInvoiceCustomFields($invoiceId, $xKillbillCreatedBy, $customField = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        $this->deleteInvoiceCustomFieldsWithHttpInfo($invoiceId, $xKillbillCreatedBy, $customField, $xKillbillReason, $xKillbillComment);
    }

    /**
     * Operation deleteInvoiceCustomFieldsWithHttpInfo
     *
     * Remove custom fields from invoice
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string[] $customField (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInvoiceCustomFieldsWithHttpInfo($invoiceId, $xKillbillCreatedBy, $customField = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deleteInvoiceCustomFieldsRequest($invoiceId, $xKillbillCreatedBy, $customField, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteInvoiceCustomFieldsAsync
     *
     * Remove custom fields from invoice
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string[] $customField (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceCustomFieldsAsync($invoiceId, $xKillbillCreatedBy, $customField = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->deleteInvoiceCustomFieldsAsyncWithHttpInfo($invoiceId, $xKillbillCreatedBy, $customField, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInvoiceCustomFieldsAsyncWithHttpInfo
     *
     * Remove custom fields from invoice
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string[] $customField (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceCustomFieldsAsyncWithHttpInfo($invoiceId, $xKillbillCreatedBy, $customField = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deleteInvoiceCustomFieldsRequest($invoiceId, $xKillbillCreatedBy, $customField, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInvoiceCustomFields'
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string[] $customField (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteInvoiceCustomFieldsRequest($invoiceId, $xKillbillCreatedBy, $customField = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling deleteInvoiceCustomFields'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling deleteInvoiceCustomFields'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}/customFields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($customField)) {
            $customField = ObjectSerializer::serializeCollection($customField, /*'multi'*/'csv', true);
        }
        if ($customField !== null) {
            $queryParams['customField'] = ObjectSerializer::toQueryValue($customField);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInvoiceTags
     *
     * Remove tags from invoice
     *
     * @param string $invoiceId invoiceId (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string[]|null $tagDef tagDef (optional)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteInvoiceTags($invoiceId, $xKillbillCreatedBy, $tagDef = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        $this->deleteInvoiceTagsWithHttpInfo($invoiceId, $xKillbillCreatedBy, $tagDef, $xKillbillReason, $xKillbillComment);
    }

    /**
     * Operation deleteInvoiceTagsWithHttpInfo
     *
     * Remove tags from invoice
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string[] $tagDef (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInvoiceTagsWithHttpInfo($invoiceId, $xKillbillCreatedBy, $tagDef = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deleteInvoiceTagsRequest($invoiceId, $xKillbillCreatedBy, $tagDef, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteInvoiceTagsAsync
     *
     * Remove tags from invoice
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string[] $tagDef (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceTagsAsync($invoiceId, $xKillbillCreatedBy, $tagDef = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->deleteInvoiceTagsAsyncWithHttpInfo($invoiceId, $xKillbillCreatedBy, $tagDef, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInvoiceTagsAsyncWithHttpInfo
     *
     * Remove tags from invoice
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string[] $tagDef (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceTagsAsyncWithHttpInfo($invoiceId, $xKillbillCreatedBy, $tagDef = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->deleteInvoiceTagsRequest($invoiceId, $xKillbillCreatedBy, $tagDef, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInvoiceTags'
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string[] $tagDef (optional)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteInvoiceTagsRequest($invoiceId, $xKillbillCreatedBy, $tagDef = null, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling deleteInvoiceTags'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling deleteInvoiceTags'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($tagDef)) {
            $tagDef = ObjectSerializer::serializeCollection($tagDef, /*'multi'*/'csv', true);
        }
        if ($tagDef !== null) {
            $queryParams['tagDef'] = ObjectSerializer::toQueryValue($tagDef);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateDryRunInvoice
     *
     * Generate a dryRun invoice
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceDryRun $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $accountId accountId (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     * @param \DateTime|null $targetDate targetDate (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Invoice
     */
    public function generateDryRunInvoice($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $targetDate = null)
    {
        list($response) = $this->generateDryRunInvoiceWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $targetDate);
        return $response;
    }

    /**
     * Operation generateDryRunInvoiceWithHttpInfo
     *
     * Generate a dryRun invoice
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceDryRun $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $targetDate (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateDryRunInvoiceWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $targetDate = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->generateDryRunInvoiceRequest($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $targetDate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateDryRunInvoiceAsync
     *
     * Generate a dryRun invoice
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceDryRun $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $targetDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateDryRunInvoiceAsync($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $targetDate = null)
    {
        return $this->generateDryRunInvoiceAsyncWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $targetDate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateDryRunInvoiceAsyncWithHttpInfo
     *
     * Generate a dryRun invoice
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceDryRun $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $targetDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateDryRunInvoiceAsyncWithHttpInfo($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $targetDate = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->generateDryRunInvoiceRequest($body, $xKillbillCreatedBy, $accountId, $xKillbillReason, $xKillbillComment, $targetDate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateDryRunInvoice'
     *
     * @param \Killbill\Client\Swagger\Model\InvoiceDryRun $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $accountId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param \DateTime $targetDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function generateDryRunInvoiceRequest($body, $xKillbillCreatedBy, $accountId, $xKillbillReason = null, $xKillbillComment = null, $targetDate = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling generateDryRunInvoice'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling generateDryRunInvoice'
            );
        }
        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling generateDryRunInvoice'
            );
        }

        $resourcePath = '/1.0/kb/invoices/dryRun';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($accountId !== null) {
            $queryParams['accountId'] = ObjectSerializer::toQueryValue($accountId);
        }
        // query params
        if ($targetDate !== null) {
            $queryParams['targetDate'] = ObjectSerializer::toQueryValue($targetDate);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCatalogTranslation
     *
     * Retrieves the catalog translation for the tenant
     *
     * @param string $locale locale (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getCatalogTranslation($locale)
    {
        list($response) = $this->getCatalogTranslationWithHttpInfo($locale);
        return $response;
    }

    /**
     * Operation getCatalogTranslationWithHttpInfo
     *
     * Retrieves the catalog translation for the tenant
     *
     * @param string $locale (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCatalogTranslationWithHttpInfo($locale)
    {
        $returnType = 'string';
        $request = $this->getCatalogTranslationRequest($locale);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCatalogTranslationAsync
     *
     * Retrieves the catalog translation for the tenant
     *
     * @param string $locale (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCatalogTranslationAsync($locale)
    {
        return $this->getCatalogTranslationAsyncWithHttpInfo($locale)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCatalogTranslationAsyncWithHttpInfo
     *
     * Retrieves the catalog translation for the tenant
     *
     * @param string $locale (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCatalogTranslationAsyncWithHttpInfo($locale)
    {
        $returnType = 'string';
        $request = $this->getCatalogTranslationRequest($locale);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCatalogTranslation'
     *
     * @param string $locale (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCatalogTranslationRequest($locale)
    {
        // verify the required parameter 'locale' is set
        if ($locale === null || (is_array($locale) && count($locale) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $locale when calling getCatalogTranslation'
            );
        }

        $resourcePath = '/1.0/kb/invoices/catalogTranslation/{locale}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($locale !== null) {
            $resourcePath = str_replace(
                '{' . 'locale' . '}',
                ObjectSerializer::toPathValue($locale),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoice
     *
     * Retrieve an invoice by id
     *
     * @param string $invoiceId invoiceId (required)
     * @param bool|null $withItems withItems (optional)
     * @param bool|null $withChildrenItems withChildrenItems (optional)
     * @param string|null $audit audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Invoice
     */
    public function getInvoice($invoiceId, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        list($response) = $this->getInvoiceWithHttpInfo($invoiceId, $withItems, $withChildrenItems, $audit);
        return $response;
    }

    /**
     * Operation getInvoiceWithHttpInfo
     *
     * Retrieve an invoice by id
     *
     * @param string $invoiceId (required)
     * @param bool $withItems (optional)
     * @param bool $withChildrenItems (optional)
     * @param string $audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceWithHttpInfo($invoiceId, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->getInvoiceRequest($invoiceId, $withItems, $withChildrenItems, $audit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceAsync
     *
     * Retrieve an invoice by id
     *
     * @param string $invoiceId (required)
     * @param bool $withItems (optional)
     * @param bool $withChildrenItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAsync($invoiceId, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        return $this->getInvoiceAsyncWithHttpInfo($invoiceId, $withItems, $withChildrenItems, $audit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceAsyncWithHttpInfo
     *
     * Retrieve an invoice by id
     *
     * @param string $invoiceId (required)
     * @param bool $withItems (optional)
     * @param bool $withChildrenItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAsyncWithHttpInfo($invoiceId, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->getInvoiceRequest($invoiceId, $withItems, $withChildrenItems, $audit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoice'
     *
     * @param string $invoiceId (required)
     * @param bool $withItems (optional)
     * @param bool $withChildrenItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceRequest($invoiceId, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling getInvoice'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($withItems !== null) {
            $queryParams['withItems'] = ObjectSerializer::toQueryValue($withItems);
        }
        // query params
        if ($withChildrenItems !== null) {
            $queryParams['withChildrenItems'] = ObjectSerializer::toQueryValue($withChildrenItems);
        }
        // query params
        if ($audit !== null) {
            $queryParams['audit'] = ObjectSerializer::toQueryValue($audit);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceAsHTML
     *
     * Render an invoice as HTML
     *
     * @param string $invoiceId invoiceId (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getInvoiceAsHTML($invoiceId)
    {
        list($response) = $this->getInvoiceAsHTMLWithHttpInfo($invoiceId);
        return $response;
    }

    /**
     * Operation getInvoiceAsHTMLWithHttpInfo
     *
     * Render an invoice as HTML
     *
     * @param string $invoiceId (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceAsHTMLWithHttpInfo($invoiceId)
    {
        $returnType = 'string';
        $request = $this->getInvoiceAsHTMLRequest($invoiceId);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceAsHTMLAsync
     *
     * Render an invoice as HTML
     *
     * @param string $invoiceId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAsHTMLAsync($invoiceId)
    {
        return $this->getInvoiceAsHTMLAsyncWithHttpInfo($invoiceId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceAsHTMLAsyncWithHttpInfo
     *
     * Render an invoice as HTML
     *
     * @param string $invoiceId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAsHTMLAsyncWithHttpInfo($invoiceId)
    {
        $returnType = 'string';
        $request = $this->getInvoiceAsHTMLRequest($invoiceId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceAsHTML'
     *
     * @param string $invoiceId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceAsHTMLRequest($invoiceId)
    {
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling getInvoiceAsHTML'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceByItemId
     *
     * Retrieve an invoice by invoice item id
     *
     * @param string $itemId itemId (required)
     * @param bool|null $withItems withItems (optional)
     * @param bool|null $withChildrenItems withChildrenItems (optional)
     * @param string|null $audit audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Invoice
     */
    public function getInvoiceByItemId($itemId, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        list($response) = $this->getInvoiceByItemIdWithHttpInfo($itemId, $withItems, $withChildrenItems, $audit);
        return $response;
    }

    /**
     * Operation getInvoiceByItemIdWithHttpInfo
     *
     * Retrieve an invoice by invoice item id
     *
     * @param string $itemId (required)
     * @param bool $withItems (optional)
     * @param bool $withChildrenItems (optional)
     * @param string $audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceByItemIdWithHttpInfo($itemId, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->getInvoiceByItemIdRequest($itemId, $withItems, $withChildrenItems, $audit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceByItemIdAsync
     *
     * Retrieve an invoice by invoice item id
     *
     * @param string $itemId (required)
     * @param bool $withItems (optional)
     * @param bool $withChildrenItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceByItemIdAsync($itemId, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        return $this->getInvoiceByItemIdAsyncWithHttpInfo($itemId, $withItems, $withChildrenItems, $audit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceByItemIdAsyncWithHttpInfo
     *
     * Retrieve an invoice by invoice item id
     *
     * @param string $itemId (required)
     * @param bool $withItems (optional)
     * @param bool $withChildrenItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceByItemIdAsyncWithHttpInfo($itemId, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->getInvoiceByItemIdRequest($itemId, $withItems, $withChildrenItems, $audit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceByItemId'
     *
     * @param string $itemId (required)
     * @param bool $withItems (optional)
     * @param bool $withChildrenItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceByItemIdRequest($itemId, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        // verify the required parameter 'itemId' is set
        if ($itemId === null || (is_array($itemId) && count($itemId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $itemId when calling getInvoiceByItemId'
            );
        }

        $resourcePath = '/1.0/kb/invoices/byItemId/{itemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($withItems !== null) {
            $queryParams['withItems'] = ObjectSerializer::toQueryValue($withItems);
        }
        // query params
        if ($withChildrenItems !== null) {
            $queryParams['withChildrenItems'] = ObjectSerializer::toQueryValue($withChildrenItems);
        }
        // query params
        if ($audit !== null) {
            $queryParams['audit'] = ObjectSerializer::toQueryValue($audit);
        }

        // path params
        if ($itemId !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($itemId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceByNumber
     *
     * Retrieve an invoice by number
     *
     * @param int $invoiceNumber invoiceNumber (required)
     * @param bool|null $withItems withItems (optional)
     * @param bool|null $withChildrenItems withChildrenItems (optional)
     * @param string|null $audit audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Invoice
     */
    public function getInvoiceByNumber($invoiceNumber, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        list($response) = $this->getInvoiceByNumberWithHttpInfo($invoiceNumber, $withItems, $withChildrenItems, $audit);
        return $response;
    }

    /**
     * Operation getInvoiceByNumberWithHttpInfo
     *
     * Retrieve an invoice by number
     *
     * @param int $invoiceNumber (required)
     * @param bool $withItems (optional)
     * @param bool $withChildrenItems (optional)
     * @param string $audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceByNumberWithHttpInfo($invoiceNumber, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->getInvoiceByNumberRequest($invoiceNumber, $withItems, $withChildrenItems, $audit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceByNumberAsync
     *
     * Retrieve an invoice by number
     *
     * @param int $invoiceNumber (required)
     * @param bool $withItems (optional)
     * @param bool $withChildrenItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceByNumberAsync($invoiceNumber, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        return $this->getInvoiceByNumberAsyncWithHttpInfo($invoiceNumber, $withItems, $withChildrenItems, $audit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceByNumberAsyncWithHttpInfo
     *
     * Retrieve an invoice by number
     *
     * @param int $invoiceNumber (required)
     * @param bool $withItems (optional)
     * @param bool $withChildrenItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceByNumberAsyncWithHttpInfo($invoiceNumber, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice';
        $request = $this->getInvoiceByNumberRequest($invoiceNumber, $withItems, $withChildrenItems, $audit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceByNumber'
     *
     * @param int $invoiceNumber (required)
     * @param bool $withItems (optional)
     * @param bool $withChildrenItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceByNumberRequest($invoiceNumber, $withItems = null, $withChildrenItems = null, $audit = null)
    {
        // verify the required parameter 'invoiceNumber' is set
        if ($invoiceNumber === null || (is_array($invoiceNumber) && count($invoiceNumber) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceNumber when calling getInvoiceByNumber'
            );
        }

        $resourcePath = '/1.0/kb/invoices/byNumber/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($withItems !== null) {
            $queryParams['withItems'] = ObjectSerializer::toQueryValue($withItems);
        }
        // query params
        if ($withChildrenItems !== null) {
            $queryParams['withChildrenItems'] = ObjectSerializer::toQueryValue($withChildrenItems);
        }
        // query params
        if ($audit !== null) {
            $queryParams['audit'] = ObjectSerializer::toQueryValue($audit);
        }

        // path params
        if ($invoiceNumber !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoiceNumber),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceCustomFields
     *
     * Retrieve invoice custom fields
     *
     * @param string $invoiceId invoiceId (required)
     * @param string|null $audit audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\CustomField[]
     */
    public function getInvoiceCustomFields($invoiceId, $audit = null)
    {
        list($response) = $this->getInvoiceCustomFieldsWithHttpInfo($invoiceId, $audit);
        return $response;
    }

    /**
     * Operation getInvoiceCustomFieldsWithHttpInfo
     *
     * Retrieve invoice custom fields
     *
     * @param string $invoiceId (required)
     * @param string $audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\CustomField[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceCustomFieldsWithHttpInfo($invoiceId, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\CustomField[]';
        $request = $this->getInvoiceCustomFieldsRequest($invoiceId, $audit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\CustomField[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceCustomFieldsAsync
     *
     * Retrieve invoice custom fields
     *
     * @param string $invoiceId (required)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceCustomFieldsAsync($invoiceId, $audit = null)
    {
        return $this->getInvoiceCustomFieldsAsyncWithHttpInfo($invoiceId, $audit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceCustomFieldsAsyncWithHttpInfo
     *
     * Retrieve invoice custom fields
     *
     * @param string $invoiceId (required)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceCustomFieldsAsyncWithHttpInfo($invoiceId, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\CustomField[]';
        $request = $this->getInvoiceCustomFieldsRequest($invoiceId, $audit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceCustomFields'
     *
     * @param string $invoiceId (required)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceCustomFieldsRequest($invoiceId, $audit = null)
    {
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling getInvoiceCustomFields'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}/customFields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($audit !== null) {
            $queryParams['audit'] = ObjectSerializer::toQueryValue($audit);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceMPTemplate
     *
     * Retrieves the manualPay invoice template for the tenant
     *
     * @param string $locale locale (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getInvoiceMPTemplate($locale)
    {
        list($response) = $this->getInvoiceMPTemplateWithHttpInfo($locale);
        return $response;
    }

    /**
     * Operation getInvoiceMPTemplateWithHttpInfo
     *
     * Retrieves the manualPay invoice template for the tenant
     *
     * @param string $locale (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceMPTemplateWithHttpInfo($locale)
    {
        $returnType = 'string';
        $request = $this->getInvoiceMPTemplateRequest($locale);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceMPTemplateAsync
     *
     * Retrieves the manualPay invoice template for the tenant
     *
     * @param string $locale (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceMPTemplateAsync($locale)
    {
        return $this->getInvoiceMPTemplateAsyncWithHttpInfo($locale)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceMPTemplateAsyncWithHttpInfo
     *
     * Retrieves the manualPay invoice template for the tenant
     *
     * @param string $locale (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceMPTemplateAsyncWithHttpInfo($locale)
    {
        $returnType = 'string';
        $request = $this->getInvoiceMPTemplateRequest($locale);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceMPTemplate'
     *
     * @param string $locale (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceMPTemplateRequest($locale)
    {
        // verify the required parameter 'locale' is set
        if ($locale === null || (is_array($locale) && count($locale) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $locale when calling getInvoiceMPTemplate'
            );
        }

        $resourcePath = '/1.0/kb/invoices/manualPayTemplate/{locale}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($locale !== null) {
            $resourcePath = str_replace(
                '{' . 'locale' . '}',
                ObjectSerializer::toPathValue($locale),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceTags
     *
     * Retrieve invoice tags
     *
     * @param string $invoiceId invoiceId (required)
     * @param bool|null $includedDeleted includedDeleted (optional)
     * @param string|null $audit audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Tag[]
     */
    public function getInvoiceTags($invoiceId, $includedDeleted = null, $audit = null)
    {
        list($response) = $this->getInvoiceTagsWithHttpInfo($invoiceId, $includedDeleted, $audit);
        return $response;
    }

    /**
     * Operation getInvoiceTagsWithHttpInfo
     *
     * Retrieve invoice tags
     *
     * @param string $invoiceId (required)
     * @param bool $includedDeleted (optional)
     * @param string $audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Tag[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceTagsWithHttpInfo($invoiceId, $includedDeleted = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Tag[]';
        $request = $this->getInvoiceTagsRequest($invoiceId, $includedDeleted, $audit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Tag[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceTagsAsync
     *
     * Retrieve invoice tags
     *
     * @param string $invoiceId (required)
     * @param bool $includedDeleted (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceTagsAsync($invoiceId, $includedDeleted = null, $audit = null)
    {
        return $this->getInvoiceTagsAsyncWithHttpInfo($invoiceId, $includedDeleted, $audit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceTagsAsyncWithHttpInfo
     *
     * Retrieve invoice tags
     *
     * @param string $invoiceId (required)
     * @param bool $includedDeleted (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceTagsAsyncWithHttpInfo($invoiceId, $includedDeleted = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Tag[]';
        $request = $this->getInvoiceTagsRequest($invoiceId, $includedDeleted, $audit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceTags'
     *
     * @param string $invoiceId (required)
     * @param bool $includedDeleted (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceTagsRequest($invoiceId, $includedDeleted = null, $audit = null)
    {
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling getInvoiceTags'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($includedDeleted !== null) {
            $queryParams['includedDeleted'] = ObjectSerializer::toQueryValue($includedDeleted);
        }
        // query params
        if ($audit !== null) {
            $queryParams['audit'] = ObjectSerializer::toQueryValue($audit);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceTemplate
     *
     * Retrieves the invoice template for the tenant
     *
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getInvoiceTemplate()
    {
        list($response) = $this->getInvoiceTemplateWithHttpInfo();
        return $response;
    }

    /**
     * Operation getInvoiceTemplateWithHttpInfo
     *
     * Retrieves the invoice template for the tenant
     *
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceTemplateWithHttpInfo()
    {
        $returnType = 'string';
        $request = $this->getInvoiceTemplateRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceTemplateAsync
     *
     * Retrieves the invoice template for the tenant
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceTemplateAsync()
    {
        return $this->getInvoiceTemplateAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceTemplateAsyncWithHttpInfo
     *
     * Retrieves the invoice template for the tenant
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceTemplateAsyncWithHttpInfo()
    {
        $returnType = 'string';
        $request = $this->getInvoiceTemplateRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceTemplate'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceTemplateRequest()
    {

        $resourcePath = '/1.0/kb/invoices/template';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoiceTranslation
     *
     * Retrieves the invoice translation for the tenant
     *
     * @param string $locale locale (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getInvoiceTranslation($locale)
    {
        list($response) = $this->getInvoiceTranslationWithHttpInfo($locale);
        return $response;
    }

    /**
     * Operation getInvoiceTranslationWithHttpInfo
     *
     * Retrieves the invoice translation for the tenant
     *
     * @param string $locale (required)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceTranslationWithHttpInfo($locale)
    {
        $returnType = 'string';
        $request = $this->getInvoiceTranslationRequest($locale);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceTranslationAsync
     *
     * Retrieves the invoice translation for the tenant
     *
     * @param string $locale (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceTranslationAsync($locale)
    {
        return $this->getInvoiceTranslationAsyncWithHttpInfo($locale)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceTranslationAsyncWithHttpInfo
     *
     * Retrieves the invoice translation for the tenant
     *
     * @param string $locale (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceTranslationAsyncWithHttpInfo($locale)
    {
        $returnType = 'string';
        $request = $this->getInvoiceTranslationRequest($locale);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceTranslation'
     *
     * @param string $locale (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoiceTranslationRequest($locale)
    {
        // verify the required parameter 'locale' is set
        if ($locale === null || (is_array($locale) && count($locale) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $locale when calling getInvoiceTranslation'
            );
        }

        $resourcePath = '/1.0/kb/invoices/translation/{locale}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($locale !== null) {
            $resourcePath = str_replace(
                '{' . 'locale' . '}',
                ObjectSerializer::toPathValue($locale),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoices
     *
     * List invoices
     *
     * @param int|null $offset offset (optional)
     * @param int|null $limit limit (optional)
     * @param bool|null $withItems withItems (optional)
     * @param string|null $audit audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Invoice[]
     */
    public function getInvoices($offset = null, $limit = null, $withItems = null, $audit = null)
    {
        list($response) = $this->getInvoicesWithHttpInfo($offset, $limit, $withItems, $audit);
        return $response;
    }

    /**
     * Operation getInvoicesWithHttpInfo
     *
     * List invoices
     *
     * @param int $offset (optional)
     * @param int $limit (optional)
     * @param bool $withItems (optional)
     * @param string $audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Invoice[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoicesWithHttpInfo($offset = null, $limit = null, $withItems = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice[]';
        $request = $this->getInvoicesRequest($offset, $limit, $withItems, $audit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Invoice[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoicesAsync
     *
     * List invoices
     *
     * @param int $offset (optional)
     * @param int $limit (optional)
     * @param bool $withItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoicesAsync($offset = null, $limit = null, $withItems = null, $audit = null)
    {
        return $this->getInvoicesAsyncWithHttpInfo($offset, $limit, $withItems, $audit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoicesAsyncWithHttpInfo
     *
     * List invoices
     *
     * @param int $offset (optional)
     * @param int $limit (optional)
     * @param bool $withItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoicesAsyncWithHttpInfo($offset = null, $limit = null, $withItems = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice[]';
        $request = $this->getInvoicesRequest($offset, $limit, $withItems, $audit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoices'
     *
     * @param int $offset (optional)
     * @param int $limit (optional)
     * @param bool $withItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInvoicesRequest($offset = null, $limit = null, $withItems = null, $audit = null)
    {

        $resourcePath = '/1.0/kb/invoices/pagination';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($withItems !== null) {
            $queryParams['withItems'] = ObjectSerializer::toQueryValue($withItems);
        }
        // query params
        if ($audit !== null) {
            $queryParams['audit'] = ObjectSerializer::toQueryValue($audit);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentsForInvoice
     *
     * Retrieve payments associated with an invoice
     *
     * @param string $invoiceId invoiceId (required)
     * @param bool|null $withPluginInfo withPluginInfo (optional)
     * @param bool|null $withAttempts withAttempts (optional)
     * @param string|null $audit audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\InvoicePayment[]
     */
    public function getPaymentsForInvoice($invoiceId, $withPluginInfo = null, $withAttempts = null, $audit = null)
    {
        list($response) = $this->getPaymentsForInvoiceWithHttpInfo($invoiceId, $withPluginInfo, $withAttempts, $audit);
        return $response;
    }

    /**
     * Operation getPaymentsForInvoiceWithHttpInfo
     *
     * Retrieve payments associated with an invoice
     *
     * @param string $invoiceId (required)
     * @param bool $withPluginInfo (optional)
     * @param bool $withAttempts (optional)
     * @param string $audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\InvoicePayment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentsForInvoiceWithHttpInfo($invoiceId, $withPluginInfo = null, $withAttempts = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\InvoicePayment[]';
        $request = $this->getPaymentsForInvoiceRequest($invoiceId, $withPluginInfo, $withAttempts, $audit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\InvoicePayment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentsForInvoiceAsync
     *
     * Retrieve payments associated with an invoice
     *
     * @param string $invoiceId (required)
     * @param bool $withPluginInfo (optional)
     * @param bool $withAttempts (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentsForInvoiceAsync($invoiceId, $withPluginInfo = null, $withAttempts = null, $audit = null)
    {
        return $this->getPaymentsForInvoiceAsyncWithHttpInfo($invoiceId, $withPluginInfo, $withAttempts, $audit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentsForInvoiceAsyncWithHttpInfo
     *
     * Retrieve payments associated with an invoice
     *
     * @param string $invoiceId (required)
     * @param bool $withPluginInfo (optional)
     * @param bool $withAttempts (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentsForInvoiceAsyncWithHttpInfo($invoiceId, $withPluginInfo = null, $withAttempts = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\InvoicePayment[]';
        $request = $this->getPaymentsForInvoiceRequest($invoiceId, $withPluginInfo, $withAttempts, $audit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentsForInvoice'
     *
     * @param string $invoiceId (required)
     * @param bool $withPluginInfo (optional)
     * @param bool $withAttempts (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPaymentsForInvoiceRequest($invoiceId, $withPluginInfo = null, $withAttempts = null, $audit = null)
    {
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling getPaymentsForInvoice'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}/payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($withPluginInfo !== null) {
            $queryParams['withPluginInfo'] = ObjectSerializer::toQueryValue($withPluginInfo);
        }
        // query params
        if ($withAttempts !== null) {
            $queryParams['withAttempts'] = ObjectSerializer::toQueryValue($withAttempts);
        }
        // query params
        if ($audit !== null) {
            $queryParams['audit'] = ObjectSerializer::toQueryValue($audit);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modifyInvoiceCustomFields
     *
     * Modify custom fields to invoice
     *
     * @param \Killbill\Client\Swagger\Model\CustomField[] $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $invoiceId invoiceId (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function modifyInvoiceCustomFields($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        $this->modifyInvoiceCustomFieldsWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment);
    }

    /**
     * Operation modifyInvoiceCustomFieldsWithHttpInfo
     *
     * Modify custom fields to invoice
     *
     * @param \Killbill\Client\Swagger\Model\CustomField[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function modifyInvoiceCustomFieldsWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->modifyInvoiceCustomFieldsRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation modifyInvoiceCustomFieldsAsync
     *
     * Modify custom fields to invoice
     *
     * @param \Killbill\Client\Swagger\Model\CustomField[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyInvoiceCustomFieldsAsync($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->modifyInvoiceCustomFieldsAsyncWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modifyInvoiceCustomFieldsAsyncWithHttpInfo
     *
     * Modify custom fields to invoice
     *
     * @param \Killbill\Client\Swagger\Model\CustomField[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyInvoiceCustomFieldsAsyncWithHttpInfo($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->modifyInvoiceCustomFieldsRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modifyInvoiceCustomFields'
     *
     * @param \Killbill\Client\Swagger\Model\CustomField[] $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $invoiceId (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function modifyInvoiceCustomFieldsRequest($body, $xKillbillCreatedBy, $invoiceId, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling modifyInvoiceCustomFields'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling modifyInvoiceCustomFields'
            );
        }
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling modifyInvoiceCustomFields'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}/customFields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchInvoices
     *
     * Search invoices
     *
     * @param string $searchKey searchKey (required)
     * @param int|null $offset offset (optional)
     * @param int|null $limit limit (optional)
     * @param bool|null $withItems withItems (optional)
     * @param string|null $audit audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Killbill\Client\Swagger\Model\Invoice[]
     */
    public function searchInvoices($searchKey, $offset = null, $limit = null, $withItems = null, $audit = null)
    {
        list($response) = $this->searchInvoicesWithHttpInfo($searchKey, $offset, $limit, $withItems, $audit);
        return $response;
    }

    /**
     * Operation searchInvoicesWithHttpInfo
     *
     * Search invoices
     *
     * @param string $searchKey (required)
     * @param int $offset (optional)
     * @param int $limit (optional)
     * @param bool $withItems (optional)
     * @param string $audit (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Killbill\Client\Swagger\Model\Invoice[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchInvoicesWithHttpInfo($searchKey, $offset = null, $limit = null, $withItems = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice[]';
        $request = $this->searchInvoicesRequest($searchKey, $offset, $limit, $withItems, $audit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Killbill\Client\Swagger\Model\Invoice[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchInvoicesAsync
     *
     * Search invoices
     *
     * @param string $searchKey (required)
     * @param int $offset (optional)
     * @param int $limit (optional)
     * @param bool $withItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchInvoicesAsync($searchKey, $offset = null, $limit = null, $withItems = null, $audit = null)
    {
        return $this->searchInvoicesAsyncWithHttpInfo($searchKey, $offset, $limit, $withItems, $audit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchInvoicesAsyncWithHttpInfo
     *
     * Search invoices
     *
     * @param string $searchKey (required)
     * @param int $offset (optional)
     * @param int $limit (optional)
     * @param bool $withItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchInvoicesAsyncWithHttpInfo($searchKey, $offset = null, $limit = null, $withItems = null, $audit = null)
    {
        $returnType = '\Killbill\Client\Swagger\Model\Invoice[]';
        $request = $this->searchInvoicesRequest($searchKey, $offset, $limit, $withItems, $audit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchInvoices'
     *
     * @param string $searchKey (required)
     * @param int $offset (optional)
     * @param int $limit (optional)
     * @param bool $withItems (optional)
     * @param string $audit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchInvoicesRequest($searchKey, $offset = null, $limit = null, $withItems = null, $audit = null)
    {
        // verify the required parameter 'searchKey' is set
        if ($searchKey === null || (is_array($searchKey) && count($searchKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $searchKey when calling searchInvoices'
            );
        }

        $resourcePath = '/1.0/kb/invoices/search/{searchKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($withItems !== null) {
            $queryParams['withItems'] = ObjectSerializer::toQueryValue($withItems);
        }
        // query params
        if ($audit !== null) {
            $queryParams['audit'] = ObjectSerializer::toQueryValue($audit);
        }

        // path params
        if ($searchKey !== null) {
            $resourcePath = str_replace(
                '{' . 'searchKey' . '}',
                ObjectSerializer::toPathValue($searchKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadCatalogTranslation
     *
     * Upload the catalog translation for the tenant
     *
     * @param string $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $locale locale (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     * @param bool|null $deleteIfExists deleteIfExists (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function uploadCatalogTranslation($body, $xKillbillCreatedBy, $locale, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        list($response) = $this->uploadCatalogTranslationWithHttpInfo($body, $xKillbillCreatedBy, $locale, $xKillbillReason, $xKillbillComment, $deleteIfExists);
        return $response;
    }

    /**
     * Operation uploadCatalogTranslationWithHttpInfo
     *
     * Upload the catalog translation for the tenant
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $locale (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadCatalogTranslationWithHttpInfo($body, $xKillbillCreatedBy, $locale, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        $returnType = 'string';
        $request = $this->uploadCatalogTranslationRequest($body, $xKillbillCreatedBy, $locale, $xKillbillReason, $xKillbillComment, $deleteIfExists);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadCatalogTranslationAsync
     *
     * Upload the catalog translation for the tenant
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $locale (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadCatalogTranslationAsync($body, $xKillbillCreatedBy, $locale, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        return $this->uploadCatalogTranslationAsyncWithHttpInfo($body, $xKillbillCreatedBy, $locale, $xKillbillReason, $xKillbillComment, $deleteIfExists)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadCatalogTranslationAsyncWithHttpInfo
     *
     * Upload the catalog translation for the tenant
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $locale (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadCatalogTranslationAsyncWithHttpInfo($body, $xKillbillCreatedBy, $locale, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        $returnType = 'string';
        $request = $this->uploadCatalogTranslationRequest($body, $xKillbillCreatedBy, $locale, $xKillbillReason, $xKillbillComment, $deleteIfExists);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadCatalogTranslation'
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $locale (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadCatalogTranslationRequest($body, $xKillbillCreatedBy, $locale, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling uploadCatalogTranslation'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling uploadCatalogTranslation'
            );
        }
        // verify the required parameter 'locale' is set
        if ($locale === null || (is_array($locale) && count($locale) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $locale when calling uploadCatalogTranslation'
            );
        }

        $resourcePath = '/1.0/kb/invoices/catalogTranslation/{locale}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($deleteIfExists !== null) {
            $queryParams['deleteIfExists'] = ObjectSerializer::toQueryValue($deleteIfExists);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($locale !== null) {
            $resourcePath = str_replace(
                '{' . 'locale' . '}',
                ObjectSerializer::toPathValue($locale),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadInvoiceMPTemplate
     *
     * Upload the manualPay invoice template for the tenant
     *
     * @param string $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     * @param bool|null $deleteIfExists deleteIfExists (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function uploadInvoiceMPTemplate($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        list($response) = $this->uploadInvoiceMPTemplateWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment, $deleteIfExists);
        return $response;
    }

    /**
     * Operation uploadInvoiceMPTemplateWithHttpInfo
     *
     * Upload the manualPay invoice template for the tenant
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadInvoiceMPTemplateWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        $returnType = 'string';
        $request = $this->uploadInvoiceMPTemplateRequest($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment, $deleteIfExists);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadInvoiceMPTemplateAsync
     *
     * Upload the manualPay invoice template for the tenant
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadInvoiceMPTemplateAsync($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        return $this->uploadInvoiceMPTemplateAsyncWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment, $deleteIfExists)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadInvoiceMPTemplateAsyncWithHttpInfo
     *
     * Upload the manualPay invoice template for the tenant
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadInvoiceMPTemplateAsyncWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        $returnType = 'string';
        $request = $this->uploadInvoiceMPTemplateRequest($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment, $deleteIfExists);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadInvoiceMPTemplate'
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadInvoiceMPTemplateRequest($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling uploadInvoiceMPTemplate'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling uploadInvoiceMPTemplate'
            );
        }

        $resourcePath = '/1.0/kb/invoices/manualPayTemplate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($deleteIfExists !== null) {
            $queryParams['deleteIfExists'] = ObjectSerializer::toQueryValue($deleteIfExists);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['text/html']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadInvoiceTemplate
     *
     * Upload the invoice template for the tenant
     *
     * @param string $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     * @param bool|null $deleteIfExists deleteIfExists (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function uploadInvoiceTemplate($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        list($response) = $this->uploadInvoiceTemplateWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment, $deleteIfExists);
        return $response;
    }

    /**
     * Operation uploadInvoiceTemplateWithHttpInfo
     *
     * Upload the invoice template for the tenant
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadInvoiceTemplateWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        $returnType = 'string';
        $request = $this->uploadInvoiceTemplateRequest($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment, $deleteIfExists);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadInvoiceTemplateAsync
     *
     * Upload the invoice template for the tenant
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadInvoiceTemplateAsync($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        return $this->uploadInvoiceTemplateAsyncWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment, $deleteIfExists)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadInvoiceTemplateAsyncWithHttpInfo
     *
     * Upload the invoice template for the tenant
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadInvoiceTemplateAsyncWithHttpInfo($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        $returnType = 'string';
        $request = $this->uploadInvoiceTemplateRequest($body, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment, $deleteIfExists);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadInvoiceTemplate'
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadInvoiceTemplateRequest($body, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling uploadInvoiceTemplate'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling uploadInvoiceTemplate'
            );
        }

        $resourcePath = '/1.0/kb/invoices/template';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($deleteIfExists !== null) {
            $queryParams['deleteIfExists'] = ObjectSerializer::toQueryValue($deleteIfExists);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['text/html']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadInvoiceTranslation
     *
     * Upload the invoice translation for the tenant
     *
     * @param string $body body (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string $locale locale (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     * @param bool|null $deleteIfExists deleteIfExists (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function uploadInvoiceTranslation($body, $xKillbillCreatedBy, $locale, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        list($response) = $this->uploadInvoiceTranslationWithHttpInfo($body, $xKillbillCreatedBy, $locale, $xKillbillReason, $xKillbillComment, $deleteIfExists);
        return $response;
    }

    /**
     * Operation uploadInvoiceTranslationWithHttpInfo
     *
     * Upload the invoice translation for the tenant
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $locale (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadInvoiceTranslationWithHttpInfo($body, $xKillbillCreatedBy, $locale, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        $returnType = 'string';
        $request = $this->uploadInvoiceTranslationRequest($body, $xKillbillCreatedBy, $locale, $xKillbillReason, $xKillbillComment, $deleteIfExists);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadInvoiceTranslationAsync
     *
     * Upload the invoice translation for the tenant
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $locale (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadInvoiceTranslationAsync($body, $xKillbillCreatedBy, $locale, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        return $this->uploadInvoiceTranslationAsyncWithHttpInfo($body, $xKillbillCreatedBy, $locale, $xKillbillReason, $xKillbillComment, $deleteIfExists)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadInvoiceTranslationAsyncWithHttpInfo
     *
     * Upload the invoice translation for the tenant
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $locale (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadInvoiceTranslationAsyncWithHttpInfo($body, $xKillbillCreatedBy, $locale, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        $returnType = 'string';
        $request = $this->uploadInvoiceTranslationRequest($body, $xKillbillCreatedBy, $locale, $xKillbillReason, $xKillbillComment, $deleteIfExists);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadInvoiceTranslation'
     *
     * @param string $body (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $locale (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     * @param bool $deleteIfExists (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadInvoiceTranslationRequest($body, $xKillbillCreatedBy, $locale, $xKillbillReason = null, $xKillbillComment = null, $deleteIfExists = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling uploadInvoiceTranslation'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling uploadInvoiceTranslation'
            );
        }
        // verify the required parameter 'locale' is set
        if ($locale === null || (is_array($locale) && count($locale) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $locale when calling uploadInvoiceTranslation'
            );
        }

        $resourcePath = '/1.0/kb/invoices/translation/{locale}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($deleteIfExists !== null) {
            $queryParams['deleteIfExists'] = ObjectSerializer::toQueryValue($deleteIfExists);
        }
        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($locale !== null) {
            $resourcePath = str_replace(
                '{' . 'locale' . '}',
                ObjectSerializer::toPathValue($locale),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation voidInvoice
     *
     * Perform the action of voiding an invoice
     *
     * @param string $invoiceId invoiceId (required)
     * @param string $xKillbillCreatedBy xKillbillCreatedBy (required)
     * @param string|null $xKillbillReason xKillbillReason (optional)
     * @param string|null $xKillbillComment xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function voidInvoice($invoiceId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $this->voidInvoiceWithHttpInfo($invoiceId, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);
    }

    /**
     * Operation voidInvoiceWithHttpInfo
     *
     * Perform the action of voiding an invoice
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function voidInvoiceWithHttpInfo($invoiceId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->voidInvoiceRequest($invoiceId, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return $this->handleResponse($request, $response, $returnType);
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation voidInvoiceAsync
     *
     * Perform the action of voiding an invoice
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voidInvoiceAsync($invoiceId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        return $this->voidInvoiceAsyncWithHttpInfo($invoiceId, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation voidInvoiceAsyncWithHttpInfo
     *
     * Perform the action of voiding an invoice
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voidInvoiceAsyncWithHttpInfo($invoiceId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        $returnType = null;
        $request = $this->voidInvoiceRequest($invoiceId, $xKillbillCreatedBy, $xKillbillReason, $xKillbillComment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($request, $returnType) {
                    return $this->handleResponse($request, $response, $returnType);
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'voidInvoice'
     *
     * @param string $invoiceId (required)
     * @param string $xKillbillCreatedBy (required)
     * @param string $xKillbillReason (optional)
     * @param string $xKillbillComment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voidInvoiceRequest($invoiceId, $xKillbillCreatedBy, $xKillbillReason = null, $xKillbillComment = null)
    {
        // verify the required parameter 'invoiceId' is set
        if ($invoiceId === null || (is_array($invoiceId) && count($invoiceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoiceId when calling voidInvoice'
            );
        }
        // verify the required parameter 'xKillbillCreatedBy' is set
        if ($xKillbillCreatedBy === null || (is_array($xKillbillCreatedBy) && count($xKillbillCreatedBy) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xKillbillCreatedBy when calling voidInvoice'
            );
        }

        $resourcePath = '/1.0/kb/invoices/{invoiceId}/voidInvoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($xKillbillCreatedBy !== null) {
            $headerParams['X-Killbill-CreatedBy'] = ObjectSerializer::toHeaderValue($xKillbillCreatedBy);
        }
        // header params
        if ($xKillbillReason !== null) {
            $headerParams['X-Killbill-Reason'] = ObjectSerializer::toHeaderValue($xKillbillReason);
        }
        // header params
        if ($xKillbillComment !== null) {
            $headerParams['X-Killbill-Comment'] = ObjectSerializer::toHeaderValue($xKillbillComment);
        }

        // path params
        if ($invoiceId !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoiceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            } elseif (is_array($httpBody) && $headers['Content-Type'] === 'application/json') {
                $httpBody = array_map(function($value) {
                    return ObjectSerializer::sanitizeForSerialization($value);
                }, $_tempBody);
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiKey');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiKey'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Killbill-ApiSecret');
        if ($apiKey !== null) {
            $headers['X-Killbill-ApiSecret'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }


    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
    
    /**
     * Response handler
     *
     * @param Request  $request    Request
     * @param Response $response   Response
     * @param string   $returnType Return type
     *
     * @throws \Killbill\Client\Swagger\ApiException on non-2xx response
     * @return array of returned object matching type, HTTP status code, HTTP response headers (array of strings)
     */
    protected function handleResponse($request, $response, $returnType)
    {
        $statusCode = $response->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    $request->getUri()
                ),
                $statusCode,
                $response->getHeaders(),
                $response->getBody()
            );
        }

        if ($statusCode === 201 && $response->hasHeader('Location')) {
            // This is a Created redirection, getting the object from the location target
            $location = $response->getHeader('Location')[0];

            if (strpos($location, $this->config->getHost()) !== 0) {
                throw new ApiException(
                    sprintf(
                        '[%d] Received a location header not matching the configured host (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $options = $this->createHttpClientOption();
            $locationRequest = new Request(
                'GET',
                $location,
                $request->getHeaders()
            );
            $locationResponse = $this->client->send($locationRequest, $options);

            $responseBody = $locationResponse->getBody();
        } else {
            $responseBody = $response->getBody();
        }

        if ($returnType === null || $returnType === '') {
            $returnedObject = null;
        } else {
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }
            
            $returnedObject = ObjectSerializer::deserialize($content, $returnType, []);
        }

        return [
            $returnedObject,
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }
}
